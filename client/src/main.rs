use std::{io::Read, time::Instant};

use base64::{
    prelude::{BASE64_STANDARD, BASE64_URL_SAFE},
    Engine,
};
use image::GenericImageView;
use serde::{Deserialize, Serialize};
use tarpc::{
    client,
    context::Context,
    tokio_serde::formats::{Bincode, Json},
};

#[derive(Serialize, Deserialize, Debug)]
struct Msg {
    #[serde(with = "serde_bytes")]
    data: Vec<u8>,
    // width: u32,
    // height: u32,
}

#[tarpc::service]
trait World {
    /// Returns a greeting for name.
    async fn start() -> Msg;
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let start_time = Instant::now();

    let mut transport = tarpc::serde_transport::tcp::connect("[::1]:8081", Bincode::default);
    transport.config_mut().max_frame_length(usize::MAX);

    // WorldClient is generated by the service attribute. It has a constructor `new` that takes a
    // config and any Transport as input.
    let client = WorldClient::new(client::Config::default(), transport.await?).spawn();
    let res = client.start(Context::current()).await?;

    println!("response reseive, size {}", res.data.len());

    // let msg: Msg = serde_json::from_slice(&stream)?;
    // // println!("body: {}", body.data.len());
    // println!("body: {:?} {}", msg.data.len(), msg.height);
    // println!("start decode image");
    // let img = BASE64_STANDARD.decode(msg.data)?;
    // dbg!(21);
    // println!("img shape {}", img.len());
    // // let img = image::load_from_memory(&img)?;
    // // println!("img shape {}x{}", img.width(), img.height());

    println!("time {:?}", start_time.elapsed());
    Ok(())
}
