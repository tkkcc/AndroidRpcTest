use std::{
    io::Read,
    time::{Duration, Instant},
};

use base64::{
    prelude::{BASE64_STANDARD, BASE64_URL_SAFE},
    Engine,
};
use image::GenericImageView;
use serde::{Deserialize, Serialize};
use tarpc::{
    client,
    context::Context,
    tokio_serde::formats::{Bincode, Json},
};

#[derive(Serialize, Deserialize, Debug)]
struct Msg {
    #[serde(with = "serde_bytes")]
    data: Vec<u8>,
    // width: u32,
    // height: u32,
}

#[tarpc::service]
trait World {
    /// Returns a greeting for name.
    async fn start() -> Msg;
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut transport = tarpc::serde_transport::tcp::connect("[::1]:8081", Bincode::default);
    // let mut transport = tarpc::serde_transport::unix::connect(
    //     "/data/data/com.example.androidrpctest/cache/a.sock",
    //     Bincode::default,
    // );

    transport.config_mut().max_frame_length(usize::MAX);

    // WorldClient is generated by the service attribute. It has a constructor `new` that takes a
    // config and any Transport as input.
    let client = WorldClient::new(client::Config::default(), transport.await?).spawn();
    let handler = (0..=1)
        .map(|i| {
            let c = client.clone();
            tokio::spawn(async move {
                loop {
                    let start_time = Instant::now();
                    println!("start");
                    let res = c.start(Context::current()).await?;
                    println!("response reseive, size {}", res.data.len());
                    println!("time {:?}", start_time.elapsed());
                }
                Ok::<(), anyhow::Error>(())
            })
        })
        .collect::<Vec<_>>();
    tokio::time::sleep(Duration::from_secs(10000000)).await;

    // let msg: Msg = serde_json::from_slice(&stream)?;
    // // println!("body: {}", body.data.len());
    // println!("body: {:?} {}", msg.data.len(), msg.height);
    // println!("start decode image");
    // let img = BASE64_STANDARD.decode(msg.data)?;
    // dbg!(21);
    // println!("img shape {}", img.len());
    // // let img = image::load_from_memory(&img)?;
    // // println!("img shape {}x{}", img.width(), img.height());

    Ok(())
}
